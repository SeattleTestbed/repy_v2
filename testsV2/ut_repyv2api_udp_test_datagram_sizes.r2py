"""
This tries to send UDP datagrams of varying sizes and establish sane 
upper limits for a message length check.

UDP over IPv4 can possibly handle: 65,507 bytes =
  65,535 bytes (per its 16 bit "length" field)
     - 8 bytes for the UDP header
     -20 bytes for the IPv4 header.

IPv6 jumbograms allow for UDP datagrams larger than that, but we ignore 
this for now. For reference, see Section 4 of RFC 2675.
"""
#pragma repy
#pragma out

# Payload lengths to test
lengths = [
    1000, # should work without a problem
    1600, # larger than the typical Ethernet MTU, but still fine
    9216, # the upper limit on Mac OS X, see `net.inet.udp.maxdgram`
    9217, # +1
    10000, # this is kind of large already
    65507, # the theoretical max for UDP on IPv4, see docstring
    65508, # +1
    65535, # the maximum length encodable in the header
    65536, # +1
    100000, # a nice round number to conclude
]

ip = getmyip()
port1, port2 = list(getresources()[0]["messport"])[0:2]

for length in lengths:
  log("Message length", length)
  try:
    sendmessage(ip, port1, length * ".", ip, port2)
  except RepyArgumentError:
    # I think this is how we should handle too long messages
    log("causes a RepyArgumentError as expected.")
  except Exception, e:
    log("raises", type(e), repr(e))
  else:
    log("works.")
  finally:
    log("\n")
